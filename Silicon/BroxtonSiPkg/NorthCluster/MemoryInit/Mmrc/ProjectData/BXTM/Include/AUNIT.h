/** @file
  File name:    AUNIT.h
  Input File:   BXTM_SOC.xlsx

  THIS FILE IS AUTO-GENERATED BY THE MMRC TOOL. DO NOT CHANGE THIS CODE.

  If edits are needed in this file, they must be done via the MMRC tool.

  If there is additional project-specific data required by the MMRC, it
  can be placed in AUNIT.h, which is used for non-tool-generated
  data

  Includes register defines specific to a project.

 @copyright
  INTEL CONFIDENTIAL
  Copyright 2005 - 2016 Intel Corporation.

  The source code contained or described herein and all documents related to the
  source code ("Material") are owned by Intel Corporation or its suppliers or
  licensors. Title to the Material remains with Intel Corporation or its suppliers
  and licensors. The Material may contain trade secrets and proprietary and
  confidential information of Intel Corporation and its suppliers and licensors,
  and is protected by worldwide copyright and trade secret laws and treaty
  provisions. No part of the Material may be used, copied, reproduced, modified,
  published, uploaded, posted, transmitted, distributed, or disclosed in any way
  without Intel's prior express written permission.

  No license under any patent, copyright, trade secret or other intellectual
  property right is granted to or conferred upon you by disclosure or delivery
  of the Materials, either expressly, by implication, inducement, estoppel or
  otherwise. Any license under such intellectual property rights must be
  express and approved by Intel in writing.

  Unless otherwise agreed by Intel in writing, you may not remove or alter
  this notice or any other notice embedded in Materials by Intel or
  Intel's suppliers or licensors in any way.

  This file contains an 'Intel Peripheral Driver' and is uniquely identified as
  "Intel Reference Module" and is licensed for Intel CPUs and chipsets under
  the terms of your license agreement with Intel or your vendor. This file may
  be modified by the user, subject to additional terms of the license agreement.

  @par Specification
**/
#ifndef _AUNIT_H_
#define _AUNIT_H_

#include "DataTypes.h"

#if USE_64_BIT_VARIABLES
#define UINTX UINT64
#else
#define UINTX UINT32
#endif

#define A_CR_UPARB_GCNT_DEV_A2T_MCHBAR_AUNIT_REG           0x00006400
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VC0APosted to Tunit MSIs
    //
    // Bits[7:0], RW, default = 0x1
    //
    UINTX vc0a_p : 8;
    //
    // VC0ACmp to Tunit
    //
    // Bits[15:8], RW, default = 0x1
    //
    UINTX vc0a_c : 8;
    //
    // VC0BPosted to Tunit MSIs
    //
    // Bits[23:16], RW, default = 0x1
    //
    UINTX vc0b_p : 8;
    //
    // VC0BCmp to Tunit
    //
    // Bits[31:24], RW, default = 0x1
    //
    UINTX vc0b_c : 8;
  } Bits;
  UINTX Data;
} A_CR_UPARB_GCNT_DEV_A2T_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_UPARB_GCNT_A2B_0_MCHBAR_AUNIT_REG             0x00006404
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VC0A posted grant count
    //
    // Bits[7:0], RW, default = 0x1
    //
    UINTX chid0_p : 8;
    //
    // VC0A NonPosted grant
    //
    // Bits[15:8], RW, default = 0x1
    //
    UINTX chid0_np : 8;
    //
    // VC0A IOMMU PTE fetch grant count
    //
    // Bits[23:16], RW, default = 0x1
    //
    UINTX chid0_mmu_np : 8;
    //
    // Tgt arb input for this Class arb
    //
    // Bits[31:24], RW, default = 0x1
    //
    UINTX chid0_tgt : 8;
  } Bits;
  UINTX Data;
} A_CR_UPARB_GCNT_A2B_0_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_UPARB_GCNT_A2B_1_MCHBAR_AUNIT_REG             0x00006408
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VC0B Posted
    //
    // Bits[7:0], RW, default = 0x1
    //
    UINTX chid1_p : 8;
    //
    // VC0B NonPosted
    //
    // Bits[15:8], RW, default = 0x1
    //
    UINTX chid1_np : 8;
    //
    // VC0B IOMMU PTE fetch
    //
    // Bits[23:16], RW, default = 0x1
    //
    UINTX chid1_mmu_np : 8;
    //
    // Tgt arb input for this Class arb
    //
    // Bits[31:24], RW, default = 0x1
    //
    UINTX chid1_tgt : 8;
  } Bits;
  UINTX Data;
} A_CR_UPARB_GCNT_A2B_1_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_UPARB_GCNT_A2B_2_MCHBAR_AUNIT_REG             0x0000640C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ReservedZ.  Not currently used.
    //
    // Bits[7:0], RO, default = 0x0
    //
    UINTX chid2_p : 8;
    //
    // VC1A Non Posted
    //
    // Bits[15:8], RW, default = 0x1
    //
    UINTX chid2_np : 8;
    //
    // ReservedZ
    //
    // Bits[23:16], RO, default = 0x0
    //
    UINTX chid2_mmu_np : 8;
    //
    // Tgt arb input for this Class arb
    //
    // Bits[31:24], RW, default = 0x1
    //
    UINTX chid2_tgt : 8;
  } Bits;
  UINTX Data;
} A_CR_UPARB_GCNT_A2B_2_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_UPARB_GCNT_A2B_3_MCHBAR_AUNIT_REG             0x00006410
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VC1B Posted
    //
    // Bits[7:0], RW, default = 0x1
    //
    UINTX chid3_p : 8;
    //
    // VC1B NonPosted
    //
    // Bits[15:8], RW, default = 0x1
    //
    UINTX chid3_np : 8;
    //
    // VC1 IOMMU PTE fetch
    //
    // Bits[23:16], RW, default = 0x1
    //
    UINTX chid3_mmu_np : 8;
    //
    // Tgt arb input for this Class arb
    //
    // Bits[31:24], RW, default = 0x1
    //
    UINTX chid3_tgt : 8;
  } Bits;
  UINTX Data;
} A_CR_UPARB_GCNT_A2B_3_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_UPARB_GCNT_A2B_4_MCHBAR_AUNIT_REG             0x00006414
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ReservedZ. Not currently used.
    //
    // Bits[7:0], RO, default = 0x0
    //
    UINTX chid4_p : 8;
    //
    // VC2A Non Posted
    //
    // Bits[15:8], RW, default = 0x1
    //
    UINTX chid4_np : 8;
    //
    // ReservedZ
    //
    // Bits[23:16], RO, default = 0x0
    //
    UINTX chid4_mmu_np : 8;
    //
    // Tgt arb input for this Class arb
    //
    // Bits[31:24], RW, default = 0x1
    //
    UINTX chid4_tgt : 8;
  } Bits;
  UINTX Data;
} A_CR_UPARB_GCNT_A2B_4_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_UPARB_GCNT_A2B_5_MCHBAR_AUNIT_REG             0x00006418
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VC2B Posted
    //
    // Bits[7:0], RW, default = 0x1
    //
    UINTX chid5_p : 8;
    //
    // VC2B Non Posted
    //
    // Bits[15:8], RW, default = 0x1
    //
    UINTX chid5_np : 8;
    //
    // ReservedZ
    //
    // Bits[23:16], RO, default = 0x0
    //
    UINTX chid5_mmu_np : 8;
    //
    // Tgt arb input for this Class arb
    //
    // Bits[31:24], RW, default = 0x1
    //
    UINTX chid5_tgt : 8;
  } Bits;
  UINTX Data;
} A_CR_UPARB_GCNT_A2B_5_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_UPARB_GCNT_A2B_6_MCHBAR_AUNIT_REG             0x0000641C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VC2C Posted
    //
    // Bits[7:0], RW, default = 0x1
    //
    UINTX chid6_p : 8;
    //
    // VC2C Non Posted
    //
    // Bits[15:8], RW, default = 0x1
    //
    UINTX chid6_np : 8;
    //
    // ReservedZ. Not currently used.
    //
    // Bits[23:16], RO, default = 0x0
    //
    UINTX chid6_mmu_np : 8;
    //
    // Tgt arb input for this Class arb
    //
    // Bits[31:24], RW, default = 0x1
    //
    UINTX chid6_tgt : 8;
  } Bits;
  UINTX Data;
} A_CR_UPARB_GCNT_A2B_6_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_UPARB_GCNT_A2B_7_MCHBAR_AUNIT_REG             0x00006420
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VCBR Posted
    //
    // Bits[7:0], RW, default = 0x1
    //
    UINTX chid7_p : 8;
    //
    // VCBR Non Posted
    //
    // Bits[15:8], RW, default = 0x1
    //
    UINTX chid7_np : 8;
    //
    // ReservedZ
    //
    // Bits[23:16], RO, default = 0x0
    //
    UINTX chid7_mmu_np : 8;
    //
    // Tgt arb input for this Class arb
    //
    // Bits[31:24], RW, default = 0x1
    //
    UINTX chid7_tgt : 8;
  } Bits;
  UINTX Data;
} A_CR_UPARB_GCNT_A2B_7_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_UPARB_GCNT_A2T_0_MCHBAR_AUNIT_REG             0x00006424
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VC0A Posted
    //
    // Bits[7:0], RW, default = 0x1
    //
    UINTX chid0_p : 8;
    //
    // VC0B Non Posted
    //
    // Bits[15:8], RW, default = 0x1
    //
    UINTX chid0_np : 8;
    //
    // Reserved
    //
    // Bits[23:16], RO, default = 0x0
    //
    UINTX chid0_mmu_np : 8;
    //
    // Tgt arb input for this Class arb
    //
    // Bits[31:24], RW, default = 0x1
    //
    UINTX chid0_tgt : 8;
  } Bits;
  UINTX Data;
} A_CR_UPARB_GCNT_A2T_0_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_UPARB_GCNT_P2P_0_MCHBAR_AUNIT_REG             0x00006428
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VC0A Posted
    //
    // Bits[7:0], RO, default = 0x1
    //
    UINTX chid0_p : 8;
    //
    // VC0A NonPosted
    //
    // Bits[15:8], RO, default = 0x1
    //
    UINTX chid0_n : 8;
    //
    // VC0A Completion
    //
    // Bits[23:16], RO, default = 0x1
    //
    UINTX chid0_c : 8;
    //
    // Tgt arb input for this Class arb
    //
    // Bits[31:24], RO, default = 0x1
    //
    UINTX chid0_tgt : 8;
  } Bits;
  UINTX Data;
} A_CR_UPARB_GCNT_P2P_0_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_UPARB_GCNT_P2P_1_MCHBAR_AUNIT_REG             0x0000642C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VC0B Posted
    //
    // Bits[7:0], RO, default = 0x1
    //
    UINTX chid1_p : 8;
    //
    // VC0B NonPosted
    //
    // Bits[15:8], RO, default = 0x1
    //
    UINTX chid1_n : 8;
    //
    // VC0B Completion
    //
    // Bits[23:16], RO, default = 0x1
    //
    UINTX chid1_c : 8;
    //
    // Tgt arb input for this Class arb
    //
    // Bits[31:24], RO, default = 0x1
    //
    UINTX chid1_tgt : 8;
  } Bits;
  UINTX Data;
} A_CR_UPARB_GCNT_P2P_1_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_CRDARB_PRIV_GCNT_DEV_P_0_MCHBAR_AUNIT_REG     0x00006430
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VC0A Posted
    //
    // Bits[7:0], RW, default = 0x1
    //
    UINTX chid0 : 8;
    //
    // VC0B Posted
    //
    // Bits[15:8], RW, default = 0x1
    //
    UINTX chid1 : 8;
    //
    // ReservedZ
    //
    // Bits[23:16], RO, default = 0x0
    //
    UINTX chid2 : 8;
    //
    // VC1B Posted
    //
    // Bits[31:24], RW, default = 0x1
    //
    UINTX chid3 : 8;
  } Bits;
  UINTX Data;
} A_CR_CRDARB_PRIV_GCNT_DEV_P_0_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_CRDARB_PRIV_GCNT_DEV_P_1_MCHBAR_AUNIT_REG     0x00006434
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ReservedZ
    //
    // Bits[7:0], RO, default = 0x0
    //
    UINTX chid4 : 8;
    //
    // VC2B Posted
    //
    // Bits[15:8], RW, default = 0x1
    //
    UINTX chid5 : 8;
    //
    // VC2C Posted
    //
    // Bits[23:16], RW, default = 0x1
    //
    UINTX chid6 : 8;
    //
    // VCBR Posted
    //
    // Bits[31:24], RW, default = 0x1
    //
    UINTX chid7 : 8;
  } Bits;
  UINTX Data;
} A_CR_CRDARB_PRIV_GCNT_DEV_P_1_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_CRDARB_PRIV_GCNT_DEV_N_0_MCHBAR_AUNIT_REG     0x00006438
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VC0A Non Posted
    //
    // Bits[7:0], RW, default = 0x1
    //
    UINTX chid0 : 8;
    //
    // VC0B Non Posted
    //
    // Bits[15:8], RW, default = 0x1
    //
    UINTX chid1 : 8;
    //
    // VC1A Non Posted
    //
    // Bits[23:16], RW, default = 0x1
    //
    UINTX chid2 : 8;
    //
    // VC1B Non Posted
    //
    // Bits[31:24], RW, default = 0x1
    //
    UINTX chid3 : 8;
  } Bits;
  UINTX Data;
} A_CR_CRDARB_PRIV_GCNT_DEV_N_0_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_CRDARB_PRIV_GCNT_DEV_N_1_MCHBAR_AUNIT_REG     0x0000643C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VC2A Non Posted
    //
    // Bits[7:0], RW, default = 0x1
    //
    UINTX chid4 : 8;
    //
    // VC2B Non Posted
    //
    // Bits[15:8], RW, default = 0x1
    //
    UINTX chid5 : 8;
    //
    // VC2C Non Posted
    //
    // Bits[23:16], RW, default = 0x1
    //
    UINTX chid6 : 8;
    //
    // VCBR Non Posted
    //
    // Bits[31:24], RW, default = 0x1
    //
    UINTX chid7 : 8;
  } Bits;
  UINTX Data;
} A_CR_CRDARB_PRIV_GCNT_DEV_N_1_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_CRDARB_PRIV_GCNT_DEV_C_0_MCHBAR_AUNIT_REG     0x00006440
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VC0A Completion
    //
    // Bits[7:0], RW, default = 0x1
    //
    UINTX chid0 : 8;
    //
    // VC0B Completion
    //
    // Bits[15:8], RW, default = 0x1
    //
    UINTX chid1 : 8;
    //
    // ReservedZ
    //
    // Bits[23:16], RO, default = 0x0
    //
    UINTX chid2 : 8;
    //
    // ReservedZ
    //
    // Bits[31:24], RO, default = 0x0
    //
    UINTX chid3 : 8;
  } Bits;
  UINTX Data;
} A_CR_CRDARB_PRIV_GCNT_DEV_C_0_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_CRDARB_SHRD_GCNT_DEV_P_0_MCHBAR_AUNIT_REG     0x00006444
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VC0A Posted
    //
    // Bits[7:0], RW, default = 0x1
    //
    UINTX chid0 : 8;
    //
    // VC0B Posted
    //
    // Bits[15:8], RW, default = 0x1
    //
    UINTX chid1 : 8;
    //
    // ReservedZ
    //
    // Bits[23:16], RO, default = 0x0
    //
    UINTX chid2 : 8;
    //
    // VC1B Posted
    //
    // Bits[31:24], RW, default = 0x1
    //
    UINTX chid3 : 8;
  } Bits;
  UINTX Data;
} A_CR_CRDARB_SHRD_GCNT_DEV_P_0_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_CRDARB_SHRD_GCNT_DEV_P_1_MCHBAR_AUNIT_REG     0x00006448
#ifndef ASM_INC
typedef union {
  struct {
    //
    // ReservedZ
    //
    // Bits[7:0], RO, default = 0x0
    //
    UINTX chid4 : 8;
    //
    // VC2B Posted
    //
    // Bits[15:8], RW, default = 0x1
    //
    UINTX chid5 : 8;
    //
    // VC2C Posted
    //
    // Bits[23:16], RW, default = 0x1
    //
    UINTX chid6 : 8;
    //
    // VCBR Posted
    //
    // Bits[31:24], RW, default = 0x1
    //
    UINTX chid7 : 8;
  } Bits;
  UINTX Data;
} A_CR_CRDARB_SHRD_GCNT_DEV_P_1_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_CRDARB_SHRD_GCNT_DEV_N_0_MCHBAR_AUNIT_REG     0x0000644C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VC0A Non Posted
    //
    // Bits[7:0], RW, default = 0x1
    //
    UINTX chid0 : 8;
    //
    // VC0B Non Posted
    //
    // Bits[15:8], RW, default = 0x1
    //
    UINTX chid1 : 8;
    //
    // VC1A Non Posted
    //
    // Bits[23:16], RW, default = 0x1
    //
    UINTX chid2 : 8;
    //
    // VC1B Non Posted
    //
    // Bits[31:24], RW, default = 0x1
    //
    UINTX chid3 : 8;
  } Bits;
  UINTX Data;
} A_CR_CRDARB_SHRD_GCNT_DEV_N_0_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_CRDARB_SHRD_GCNT_DEV_N_1_MCHBAR_AUNIT_REG     0x00006450
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VC2A Non Posted
    //
    // Bits[7:0], RW, default = 0x1
    //
    UINTX chid4 : 8;
    //
    // VC2B Non Posted
    //
    // Bits[15:8], RW, default = 0x1
    //
    UINTX chid5 : 8;
    //
    // VC2C Non Posted
    //
    // Bits[23:16], RW, default = 0x1
    //
    UINTX chid6 : 8;
    //
    // VCBR Non Posted
    //
    // Bits[31:24], RW, default = 0x1
    //
    UINTX chid7 : 8;
  } Bits;
  UINTX Data;
} A_CR_CRDARB_SHRD_GCNT_DEV_N_1_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_CRDARB_SHRD_GCNT_DEV_C_0_MCHBAR_AUNIT_REG     0x00006454
#ifndef ASM_INC
typedef union {
  struct {
    //
    // VC0A Completion
    //
    // Bits[7:0], RW, default = 0x1
    //
    UINTX chid0 : 8;
    //
    // VC0B Completion
    //
    // Bits[15:8], RW, default = 0x1
    //
    UINTX chid1 : 8;
    //
    // ReservedZ
    //
    // Bits[23:16], RO, default = 0x0
    //
    UINTX chid2 : 8;
    //
    // ReservedZ
    //
    // Bits[31:24], RO, default = 0x0
    //
    UINTX chid3 : 8;
  } Bits;
  UINTX Data;
} A_CR_CRDARB_SHRD_GCNT_DEV_C_0_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_CRDARB_PRIV_GCNT_CLS_MCHBAR_AUNIT_REG         0x00006458
#ifndef ASM_INC
typedef union {
  struct {
    //
    // All Posteds
    //
    // Bits[7:0], RW, default = 0x1
    //
    UINTX p : 8;
    //
    // All Non Posteds
    //
    // Bits[15:8], RW, default = 0x1
    //
    UINTX np : 8;
    //
    // All Completions
    //
    // Bits[23:16], RW, default = 0x1
    //
    UINTX c : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} A_CR_CRDARB_PRIV_GCNT_CLS_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_CRDARB_SHRD_GCNT_CLS_MCHBAR_AUNIT_REG         0x0000645C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // All Posteds
    //
    // Bits[7:0], RW, default = 0x1
    //
    UINTX p : 8;
    //
    // All Non Posteds
    //
    // Bits[15:8], RW, default = 0x1
    //
    UINTX np : 8;
    //
    // All Completions
    //
    // Bits[23:16], RW, default = 0x1
    //
    UINTX c : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} A_CR_CRDARB_SHRD_GCNT_CLS_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_GZLQ_LIMIT_CH0_3_MCHBAR_AUNIT_REG             0x00006460
#ifndef ASM_INC
typedef union {
  struct {
    //
    // GazelleQ limit for Upstream NP on CHID0
    //
    // Bits[7:0], RW, default = 0x8
    //
    UINTX chid0 : 8;
    //
    // GazelleQ limit for Upstream NP on CHID1
    //
    // Bits[15:8], RW, default = 0xFF
    //
    UINTX chid1 : 8;
    //
    // GazelleQ limit for Upstream NP on CHID2
    //
    // Bits[23:16], RW, default = 0xFF
    //
    UINTX chid2 : 8;
    //
    // GazelleQ limit for Upstream NP on CHID3
    //
    // Bits[31:24], RW, default = 0xFF
    //
    UINTX chid3 : 8;
  } Bits;
  UINTX Data;
} A_CR_GZLQ_LIMIT_CH0_3_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_GZLQ_LIMIT_CH4_7_MCHBAR_AUNIT_REG             0x00006464
#ifndef ASM_INC
typedef union {
  struct {
    //
    // GazelleQ limit for Upstream NP on CHID4
    //
    // Bits[7:0], RW, default = 0xFF
    //
    UINTX chid4 : 8;
    //
    // GazelleQ limit for Upstream NP on CHID5
    //
    // Bits[15:8], RW, default = 0xFF
    //
    UINTX chid5 : 8;
    //
    // GazelleQ limit for Upstream NP on CHID6
    //
    // Bits[23:16], RW, default = 0xFF
    //
    UINTX chid6 : 8;
    //
    // GazelleQ limit for Upstream NP on CHID7
    //
    // Bits[31:24], RW, default = 0xFF
    //
    UINTX chid7 : 8;
  } Bits;
  UINTX Data;
} A_CR_GZLQ_LIMIT_CH4_7_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_IOMMUARB_GCNT_VC0A_0_0_0_MCHBAR_AUNIT_REG     0x00006468
#ifndef ASM_INC
typedef union {
  struct {
    //
    // iommu arbiter device grant count for p
    //
    // Bits[7:0], RW, default = 0x1
    //
    UINTX dev_p : 8;
    //
    // iommu arbiter device grant count for np
    //
    // Bits[15:8], RW, default = 0x1
    //
    UINTX dev_np : 8;
    //
    // iommu arbiter class grant count
    //
    // Bits[23:16], RW, default = 0x1
    //
    UINTX class_cnt : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} A_CR_IOMMUARB_GCNT_VC0A_0_0_0_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_IOMMUARB_GCNT_VC0B_0_0_0_MCHBAR_AUNIT_REG     0x0000646C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // iommu arbiter device grant count for p
    //
    // Bits[7:0], RW, default = 0x1
    //
    UINTX dev_p : 8;
    //
    // iommu arbiter device grant count for np
    //
    // Bits[15:8], RW, default = 0x1
    //
    UINTX dev_np : 8;
    //
    // iommu arbiter class grant count
    //
    // Bits[23:16], RW, default = 0x1
    //
    UINTX class_cnt : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} A_CR_IOMMUARB_GCNT_VC0B_0_0_0_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_IOMMUARB_GCNT_VC1B_0_0_0_MCHBAR_AUNIT_REG     0x00006470
#ifndef ASM_INC
typedef union {
  struct {
    //
    // iommu arbiter device grant count for p
    //
    // Bits[7:0], RW, default = 0x1
    //
    UINTX dev_p : 8;
    //
    // iommu arbiter device grant count for np
    //
    // Bits[15:8], RW, default = 0x1
    //
    UINTX dev_np : 8;
    //
    // iommu arbiter class grant count
    //
    // Bits[23:16], RW, default = 0x1
    //
    UINTX class_cnt : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
  } Bits;
  UINTX Data;
} A_CR_IOMMUARB_GCNT_VC1B_0_0_0_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_GZLQ_RSVD_CH0_3_MCHBAR_AUNIT_REG              0x00006474
#ifndef ASM_INC
typedef union {
  struct {
    //
    // GazelleQ reservation for Upstream NP on CHID0
    //
    // Bits[7:0], RW, default = 0x1
    //
    UINTX chid0 : 8;
    //
    // GazelleQ reservation for Upstream NP on CHID1
    //
    // Bits[15:8], RW, default = 0x1
    //
    UINTX chid1 : 8;
    //
    // GazelleQ reservation for Upstream NP on CHID2
    //
    // Bits[23:16], RW, default = 0x4
    //
    UINTX chid2 : 8;
    //
    // GazelleQ reservation for Upstream NP on CHID3
    //
    // Bits[31:24], RW, default = 0x4
    //
    UINTX chid3 : 8;
  } Bits;
  UINTX Data;
} A_CR_GZLQ_RSVD_CH0_3_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_GZLQ_RSVD_CH4_7_MCHBAR_AUNIT_REG              0x00006478
#ifndef ASM_INC
typedef union {
  struct {
    //
    // GazelleQ reservation for Upstream NP on CHID4
    //
    // Bits[7:0], RW, default = 0x1
    //
    UINTX chid4 : 8;
    //
    // GazelleQ reservation for Upstream NP on CHID5
    //
    // Bits[15:8], RW, default = 0x1
    //
    UINTX chid5 : 8;
    //
    // GazelleQ reservation for Upstream NP on CHID6
    //
    // Bits[23:16], RW, default = 0x1
    //
    UINTX chid6 : 8;
    //
    // GazelleQ reservation for Upstream NP on CHID7
    //
    // Bits[31:24], RW, default = 0x1
    //
    UINTX chid7 : 8;
  } Bits;
  UINTX Data;
} A_CR_GZLQ_RSVD_CH4_7_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_SPARE_BIOS_MCHBAR_AUNIT_REG                   0x0000647C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Spare RW 32 bits in BIOS policy group
    //
    // Bits[31:0], RW, default = 0x0
    //
    UINTX spare_rw : 32;
  } Bits;
  UINTX Data;
} A_CR_SPARE_BIOS_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_CHAP_SLCT1_MCHBAR_AUNIT_REG                   0x00006484
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Count upstream Txn on all VCs where CHID_X[i]=1
    //
    // Bits[7:0], RW, default = 0x0
    //
    UINTX chid_x_cnt_uptxn : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
    //
    // Count upstream Txn on all VCs where CHID_Y[i]=1
    //
    // Bits[23:16], RW, default = 0x0
    //
    UINTX chid_y_cnt_uptxn : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 8;
  } Bits;
  UINTX Data;
} A_CR_CHAP_SLCT1_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_CHAP_SLCT2_MCHBAR_AUNIT_REG                   0x00006488
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Count downstream Txn on all VCs where CHID_X[i]=1
    //
    // Bits[7:0], RW, default = 0x0
    //
    UINTX chid_x_cnt_dntxn : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:8], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 8;
    //
    // Count downstream Txn on all VCs where CHID_Y[i]=1
    //
    // Bits[23:16], RW, default = 0x0
    //
    UINTX chid_y_cnt_dntxn : 8;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:24], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 8;
  } Bits;
  UINTX Data;
} A_CR_CHAP_SLCT2_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_CHAP_SLCT3_MCHBAR_AUNIT_REG                   0x0000648C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Count occupancy/residency of certain Q in Aunit00 : UpCmd;  01 : UpData;  10 :
    // GzlQ;  11 : DnCmd/Data
    //
    // Bits[1:0], RW, default = 0x0
    //
    UINTX q_occupancy_x : 2;
    //
    // Count occupancy/residency of certain Q in Aunit 00 : UpCmd;  01 : UpData;  10
    // : GzlQ;  11 : DnCmd/Data
    //
    // Bits[3:2], RW, default = 0x1
    //
    UINTX q_occupancy_y : 2;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:4], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 28;
  } Bits;
  UINTX Data;
} A_CR_CHAP_SLCT3_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_UPCMD_CRDTMAX_CH0_0_0_0_MCHBAR_AUNIT_REG      0x00006490
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Max posted credits sent to PSF0 for Chid.
    //
    // Bits[6:0], RW, default = 0xC
    //
    UINTX p_max : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Max non-posted credits sent to PSF0 for Chid.
    //
    // Bits[14:8], RW, default = 0x4
    //
    UINTX np_max : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Max Cmp credits sent to PSF0 for Chid.
    //
    // Bits[22:16], RW, default = 0x4
    //
    UINTX cmp_max : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 9;
  } Bits;
  UINTX Data;
} A_CR_UPCMD_CRDTMAX_CH0_0_0_0_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_UPCMD_CRDTMAX_CH1_0_0_0_MCHBAR_AUNIT_REG      0x00006494
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Max posted credits sent to PSF0 for Chid.
    //
    // Bits[6:0], RW, default = 0x4
    //
    UINTX p_max : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Max non-posted credits sent to PSF0 for Chid.
    //
    // Bits[14:8], RW, default = 0x4
    //
    UINTX np_max : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Max Cmp credits sent to PSF0 for Chid.
    //
    // Bits[22:16], RW, default = 0x4
    //
    UINTX cmp_max : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 9;
  } Bits;
  UINTX Data;
} A_CR_UPCMD_CRDTMAX_CH1_0_0_0_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_UPCMD_CRDTMAX_CH2_0_0_0_MCHBAR_AUNIT_REG      0x00006498
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Max posted credits sent to PSF0 for Chid.
    //
    // Bits[6:0], RW, default = 0x0
    //
    UINTX p_max : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Max non-posted credits sent to PSF0 for Chid.
    //
    // Bits[14:8], RW, default = 0x7F
    //
    UINTX np_max : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Max Cmp credits sent to PSF0 for Chid.
    //
    // Bits[22:16], RW, default = 0x0
    //
    UINTX cmp_max : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 9;
  } Bits;
  UINTX Data;
} A_CR_UPCMD_CRDTMAX_CH2_0_0_0_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_UPCMD_CRDTMAX_CH3_0_0_0_MCHBAR_AUNIT_REG      0x0000649C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Max posted credits sent to PSF0 for Chid.
    //
    // Bits[6:0], RW, default = 0x7F
    //
    UINTX p_max : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Max non-posted credits sent to PSF0 for Chid.
    //
    // Bits[14:8], RW, default = 0x7F
    //
    UINTX np_max : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Max Cmp credits sent to PSF0 for Chid.
    //
    // Bits[22:16], RW, default = 0x0
    //
    UINTX cmp_max : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 9;
  } Bits;
  UINTX Data;
} A_CR_UPCMD_CRDTMAX_CH3_0_0_0_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_UPCMD_CRDTMAX_CH4_0_0_0_MCHBAR_AUNIT_REG      0x000064A0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Max posted credits sent to PSF0 for Chid.
    //
    // Bits[6:0], RW, default = 0x0
    //
    UINTX p_max : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Max non-posted credits sent to PSF0 for Chid.
    //
    // Bits[14:8], RW, default = 0x4
    //
    UINTX np_max : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Max Cmp credits sent to PSF0 for Chid.
    //
    // Bits[22:16], RW, default = 0x0
    //
    UINTX cmp_max : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 9;
  } Bits;
  UINTX Data;
} A_CR_UPCMD_CRDTMAX_CH4_0_0_0_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_UPCMD_CRDTMAX_CH5_0_0_0_MCHBAR_AUNIT_REG      0x000064A4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Max posted credits sent to PSF0 for Chid.
    //
    // Bits[6:0], RW, default = 0x4
    //
    UINTX p_max : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Max non-posted credits sent to PSF0 for Chid.
    //
    // Bits[14:8], RW, default = 0x4
    //
    UINTX np_max : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Max Cmp credits sent to PSF0 for Chid.
    //
    // Bits[22:16], RW, default = 0x0
    //
    UINTX cmp_max : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 9;
  } Bits;
  UINTX Data;
} A_CR_UPCMD_CRDTMAX_CH5_0_0_0_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_UPCMD_CRDTMAX_CH6_0_0_0_MCHBAR_AUNIT_REG      0x000064A8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Max posted credits sent to PSF0 for Chid.
    //
    // Bits[6:0], RW, default = 0x4
    //
    UINTX p_max : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Max non-posted credits sent to PSF0 for Chid.
    //
    // Bits[14:8], RW, default = 0x4
    //
    UINTX np_max : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Max Cmp credits sent to PSF0 for Chid.
    //
    // Bits[22:16], RW, default = 0x0
    //
    UINTX cmp_max : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 9;
  } Bits;
  UINTX Data;
} A_CR_UPCMD_CRDTMAX_CH6_0_0_0_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_UPCMD_CRDTMAX_CH7_0_0_0_MCHBAR_AUNIT_REG      0x000064AC
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Max posted credits sent to PSF0 for Chid.
    //
    // Bits[6:0], RW, default = 0xC
    //
    UINTX p_max : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[7:7], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // Max non-posted credits sent to PSF0 for Chid.
    //
    // Bits[14:8], RW, default = 0x4
    //
    UINTX np_max : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[15:15], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Max Cmp credits sent to PSF0 for Chid.
    //
    // Bits[22:16], RW, default = 0x0
    //
    UINTX cmp_max : 7;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:23], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 9;
  } Bits;
  UINTX Data;
} A_CR_UPCMD_CRDTMAX_CH7_0_0_0_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_MOT_OUT_BASE_0_0_0_MCHBAR_AUNIT_REG           0x000064C0
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 14;
    //
    // Specifies bits 38:24 of the start address of the MOT memory region.  Region size
    // must be a strict poweroftwo at least 16MB and naturally aligned to the size.
    // These bits are compared with the result of the MOT_OUT_MASK[28:14] applied to
    // bits 38:24 of the incoming address to determine if an access falls within the
    // MOT region.
    //
    // Bits[28:14], RW, default = 0x0
    //
    UINTX mot_out_base : 15;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Asset Classification (AC)[0]: Trace Enable: Enables snooping of transactions to
    // the IMR region by tracing agents such as MOT.  Reserved and set to 0 for the MOT
    // region, since otherwise this would enable recursive
    //
    // Bits[30:30], RO, default = 0x0
    //
    UINTX tr_en : 1;
    //
    // IMR Enable: Enables access checking for the MOT region.  Note: this does not enable
    // MOT itself merely enables access control checks for transactions that attempt
    // to access the MOT buffer.
    //
    // Bits[31:31], RW, default = 0x0
    //
    UINTX imr_en : 1;
  } Bits;
  UINTX Data;
} A_CR_MOT_OUT_BASE_0_0_0_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_MOT_OUT_MASK_0_0_0_MCHBAR_AUNIT_REG           0x000064C4
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[13:0], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 14;
    //
    // Specifies the size of the MOT region.  If Request Address [38:24] ANDed with MOT_OUT_MASK[28:14]
    // matches the MOT_OUT_BASE[28:14] then the request falls within the MOT_OUT region
    //
    // Bits[28:14], RW, default = 0x0
    //
    UINTX mot_out_mask : 15;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[29:29], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 1;
    //
    // Asset Classification AC[1]: IA Implicit WB Enable: Enables implicit writebacks
    // to protected region from IA caching agent.  When set to 1 enables implicit writeback
    // data HITM data from IA cores to be returned to the requester.  When set to 0 inhibits
    // HITM data from IA cores from being returned to the requester.  HITM data from
    // GT may be returned to the requester depending on the setting of the GT_IWB_EN
    // bit.
    //
    // Bits[30:30], RW, default = 0x0
    //
    UINTX ia_iwb_en : 1;
    //
    // Asset Classification AC[2]: GT Implicit WB Enable: Enables implicit writebacks
    // to protected region from GT caching agent. When set to 1 enables implicit writeback
    // data HITM data from GT to be returned to the requester.  When set to 0 inhibits
    // HITM data from GT from being returned to the requester.  HITM data from IA cores
    // may be returned to the requester depending on the setting of the IA_IWB_EN bit.
    //
    // Bits[31:31], RW, default = 0x0
    //
    UINTX gt_iwb_en : 1;
  } Bits;
  UINTX Data;
} A_CR_MOT_OUT_MASK_0_0_0_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_UNCERRSTS_0_0_0_MCHBAR_AUNIT_REG              0x00006588
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Illegal/Unsupported posted opcode received from iosf.
    //
    // Bits[0:0], RW1C, default = 0x0
    //
    UINTX illegal_posted_opcode : 1;
    //
    // An incorrect/illegal sai was received with an upstream posted transaction.
    //
    // Bits[1:1], RW1C, default = 0x0
    //
    UINTX bad_sai_posted : 1;
    //
    // Illegal/Unsupported non-posted opcode received from iosf.
    //
    // Bits[2:2], RW1C, default = 0x0
    //
    UINTX illegal_nonposted_opcode : 1;
    //
    // An incorrect/illegal sai was received with an upstream non-posted transaction.
    //
    // Bits[3:3], RW1C, default = 0x0
    //
    UINTX bad_sai_nonposted : 1;
    //
    // Received a CmplLck completion from iosf.
    //
    // Bits[4:4], RW1C, default = 0x0
    //
    UINTX received_lk_cmpl : 1;
    //
    // An incorrect/illegal sai was received with an upstream completion transaction.
    //
    // Bits[5:5], RW1C, default = 0x0
    //
    UINTX bad_sai_cmpl : 1;
    //
    // The address translation (AT) bit was set to an illegal value.
    //
    // Bits[6:6], RW1C, default = 0x0
    //
    UINTX unsupported_at : 1;
    //
    // A device that is not support to set the AT bit set it to an illegal value
    //
    // Bits[7:7], RW1C, default = 0x0
    //
    UINTX at_translated_illegal_device : 1;
    //
    // A malformed/illegal MSI was received in the upstream direction
    //
    // Bits[8:8], RW1C, default = 0x0
    //
    UINTX illegal_msi : 1;
    //
    // A transaction was received with a guest physical address that was too large
    //
    // Bits[9:9], RW1C, default = 0x0
    //
    UINTX gpa_overflow : 1;
    //
    // An MSI was received with reserved bits set
    //
    // Bits[10:10], RW1C, default = 0x0
    //
    UINTX msi_rsvd_set : 1;
    //
    // reserved for future use
    //
    // Bits[11:11], RO, default = 0x0
    //
    UINTX undefined11 : 1;
    //
    // reserved for future use
    //
    // Bits[12:12], RO, default = 0x0
    //
    UINTX undefined12 : 1;
    //
    // reserved for future use
    //
    // Bits[13:13], RO, default = 0x0
    //
    UINTX undefined13 : 1;
    //
    // reserved for future use
    //
    // Bits[14:14], RO, default = 0x0
    //
    UINTX undefined14 : 1;
    //
    // reserved for future use
    //
    // Bits[15:15], RO, default = 0x0
    //
    UINTX undefined15 : 1;
    //
    // reserved for future use
    //
    // Bits[16:16], RO, default = 0x0
    //
    UINTX undefined16 : 1;
    //
    // reserved for future use
    //
    // Bits[17:17], RO, default = 0x0
    //
    UINTX undefined17 : 1;
    //
    // reserved for future use
    //
    // Bits[18:18], RO, default = 0x0
    //
    UINTX undefined18 : 1;
    //
    // reserved for future use
    //
    // Bits[19:19], RO, default = 0x0
    //
    UINTX undefined19 : 1;
    //
    // reserved for future use
    //
    // Bits[20:20], RO, default = 0x0
    //
    UINTX undefined20 : 1;
    //
    // reserved for future use
    //
    // Bits[21:21], RO, default = 0x0
    //
    UINTX undefined21 : 1;
    //
    // reserved for future use
    //
    // Bits[22:22], RO, default = 0x0
    //
    UINTX undefined22 : 1;
    //
    // reserved for future use
    //
    // Bits[23:23], RO, default = 0x0
    //
    UINTX undefined23 : 1;
    //
    // reserved for future use
    //
    // Bits[24:24], RO, default = 0x0
    //
    UINTX undefined24 : 1;
    //
    // reserved for future use
    //
    // Bits[25:25], RO, default = 0x0
    //
    UINTX undefined25 : 1;
    //
    // reserved for future use
    //
    // Bits[26:26], RO, default = 0x0
    //
    UINTX undefined26 : 1;
    //
    // reserved for future use
    //
    // Bits[27:27], RO, default = 0x0
    //
    UINTX undefined27 : 1;
    //
    // reserved for future use
    //
    // Bits[28:28], RO, default = 0x0
    //
    UINTX undefined28 : 1;
    //
    // reserved for future use
    //
    // Bits[29:29], RO, default = 0x0
    //
    UINTX undefined29 : 1;
    //
    // reserved for future use
    //
    // Bits[30:30], RO, default = 0x0
    //
    UINTX undefined30 : 1;
    //
    // reserved for future use
    //
    // Bits[31:31], RO, default = 0x0
    //
    UINTX undefined31 : 1;
  } Bits;
  UINTX Data;
} A_CR_UNCERRSTS_0_0_0_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_UNCERRMSK_0_0_0_MCHBAR_AUNIT_REG              0x0000658C
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Illegal/Unsupported posted opcode received from iosf.
    //
    // Bits[0:0], RW, default = 0x1
    //
    UINTX illegal_posted_opcode : 1;
    //
    // An incorrect/illegal sai was received with an upstream posted transaction.
    //
    // Bits[1:1], RW, default = 0x1
    //
    UINTX bad_sai_posted : 1;
    //
    // Illegal/Unsupported non-posted opcode received from iosf.
    //
    // Bits[2:2], RW, default = 0x1
    //
    UINTX illegal_nonposted_opcode : 1;
    //
    // An incorrect/illegal sai was received with an upstream non-posted transaction.
    //
    // Bits[3:3], RW, default = 0x1
    //
    UINTX bad_sai_nonposted : 1;
    //
    // Received a CmplLck completion from iosf.
    //
    // Bits[4:4], RW, default = 0x1
    //
    UINTX received_lk_cmpl : 1;
    //
    // An incorrect/illegal sai was received with an upstream completion transaction.
    //
    // Bits[5:5], RW, default = 0x1
    //
    UINTX bad_sai_cmpl : 1;
    //
    // The address translation (AT) bit was set to an illegal value.
    //
    // Bits[6:6], RW, default = 0x1
    //
    UINTX unsupported_at : 1;
    //
    // A device that is not support to set the AT bit set it to an illegal value
    //
    // Bits[7:7], RW, default = 0x1
    //
    UINTX at_translated_illegal_device : 1;
    //
    // A malformed/illegal MSI was received in the upstream direction
    //
    // Bits[8:8], RW, default = 0x1
    //
    UINTX illegal_msi : 1;
    //
    // A transaction was received with a guest physical address that was too large
    //
    // Bits[9:9], RW, default = 0x1
    //
    UINTX gpa_overflow : 1;
    //
    // An MSI was received with reserved bits set
    //
    // Bits[10:10], RW, default = 0x1
    //
    UINTX msi_rsvd_set : 1;
    //
    // reserved for future use
    //
    // Bits[11:11], RO, default = 0x1
    //
    UINTX undefined11 : 1;
    //
    // reserved for future use
    //
    // Bits[12:12], RO, default = 0x1
    //
    UINTX undefined12 : 1;
    //
    // reserved for future use
    //
    // Bits[13:13], RO, default = 0x1
    //
    UINTX undefined13 : 1;
    //
    // reserved for future use
    //
    // Bits[14:14], RO, default = 0x1
    //
    UINTX undefined14 : 1;
    //
    // reserved for future use
    //
    // Bits[15:15], RO, default = 0x1
    //
    UINTX undefined15 : 1;
    //
    // reserved for future use
    //
    // Bits[16:16], RO, default = 0x1
    //
    UINTX undefined16 : 1;
    //
    // reserved for future use
    //
    // Bits[17:17], RO, default = 0x1
    //
    UINTX undefined17 : 1;
    //
    // reserved for future use
    //
    // Bits[18:18], RO, default = 0x1
    //
    UINTX undefined18 : 1;
    //
    // reserved for future use
    //
    // Bits[19:19], RO, default = 0x1
    //
    UINTX undefined19 : 1;
    //
    // reserved for future use
    //
    // Bits[20:20], RO, default = 0x1
    //
    UINTX undefined20 : 1;
    //
    // reserved for future use
    //
    // Bits[21:21], RO, default = 0x1
    //
    UINTX undefined21 : 1;
    //
    // reserved for future use
    //
    // Bits[22:22], RO, default = 0x1
    //
    UINTX undefined22 : 1;
    //
    // reserved for future use
    //
    // Bits[23:23], RO, default = 0x1
    //
    UINTX undefined23 : 1;
    //
    // reserved for future use
    //
    // Bits[24:24], RO, default = 0x1
    //
    UINTX undefined24 : 1;
    //
    // reserved for future use
    //
    // Bits[25:25], RO, default = 0x1
    //
    UINTX undefined25 : 1;
    //
    // reserved for future use
    //
    // Bits[26:26], RO, default = 0x1
    //
    UINTX undefined26 : 1;
    //
    // reserved for future use
    //
    // Bits[27:27], RO, default = 0x1
    //
    UINTX undefined27 : 1;
    //
    // reserved for future use
    //
    // Bits[28:28], RO, default = 0x1
    //
    UINTX undefined28 : 1;
    //
    // reserved for future use
    //
    // Bits[29:29], RO, default = 0x1
    //
    UINTX undefined29 : 1;
    //
    // reserved for future use
    //
    // Bits[30:30], RO, default = 0x1
    //
    UINTX undefined30 : 1;
    //
    // reserved for future use
    //
    // Bits[31:31], RO, default = 0x1
    //
    UINTX undefined31 : 1;
  } Bits;
  UINTX Data;
} A_CR_UNCERRMSK_0_0_0_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_SLICE_CHANNEL_HASH_0_0_0_MCHBAR_AUNIT_REG     0x00006450
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Slice 1 is disabled no memory address mapped to Slice 1.  All request sent to
    // Slice 0
    //
    // Bits[0:0], RW, default = 0x0
    //
    UINTX slice_1_disabled : 1;
    //
    // 0: HVM mode is disabled.  1: HVM mode is enabled.   When HVM mode is enabled Slice
    // Hash and Channel Hash is done as follows:  Both slices and all four PMI channels
    // enabled:  Slice Hash is Request Physical Addr[29] Channel Hash is PostRemap Addr[30]
    //  Both slices enabled but only one PMI channel in each slice enabled:  Slice Hash
    // is Request Physical Addr[29]  Only one SLICE0 enabled but both PMI channels in
    // SLICE0 enabled:  Channel Hash is PostRemap Addr[29]  When HVM_MODE is enabled
    // TOLUD must be set at 2GB.
    //
    // Bits[1:1], RW, default = 0x0
    //
    UINTX hvm_mode : 1;
    //
    // Default interleave mode that specifies how the Slice Selector and Channel Selector
    // bits are to be determined.  Relevant only when HVM mode is disabled and only for
    // system memory addresses that do not fall under the MOT region or the Asymmetric
    // memory region in the System Address Map.  Legal encodings are 0x0 0x1 and 0x2.
    //  An encoding of 0x3 is treated as if it was 0x2.   When both slices and all four
    // PMI channels are enabled   0x0: Default Slice Selector is Addr[10] and Default
    // Channel Selector is Addr[11]  0x1: Default Slice Selector is Addr[11] and Default
    // Channel Selector is Addr[12]  0x2: Default Slice Selector is Addr[12] and Default
    // Channel Selector is Addr[13]  When both slices are enabled but only one channel
    // in each slice enabled:   0x0: Default Slice Selector is Addr[10]  0x1: Default
    // Slice Selector is Addr[11]  0x2: Default Slice Selector is Addr[12]  When only
    // SLICE0 is enabled and both channels on that slice are enabled:   0x0: Default
    // Channel Selector is Addr[10]  0x1: Default Channel Selector is Addr[11]  0x2:
    // Default Channel Selector is Addr[12]  When SLICE0 and only one channel in that
    // slice is enabled this field is not relevant.  Bunit overrides the setting of the
    // SLICE_HASH_MASK to always include the Slice Selector bit.  Similarly Bunit overrides
    // the setting of the CH_HASH_MASK to always include the Channel Selector bit.
    //
    // Bits[3:2], RW, default = 0x0
    //
    UINTX interleave_mode : 2;
    //
    // Slice 0 is disabled for memory accesses; no memory address mapped to Slice 0 and
    // all memory requests sent to Slice 1.  In BXT, this bit is RO with the value of
    // 0.
    //
    // Bits[4:4], RO, default = 0x0
    //
    UINTX slice_0_mem_disabled : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[5:5], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 1;
    //
    // When both slices are enabled this field specifies the Slice Hash Mask to be applied
    // on Addr[19:6] physical address of the request to compute which slice a request
    // must be routed to.  Relevant only when HVM mode is disabled and only for physical
    // addresses that do not fall under the Asymmetric Memory Region and the MOT region.
    //  Bunit will override the programmed value to include the Slice Selector bit See
    // INTERLEAVE_MODE field.  Note that HVM mode nonaddress IDI requests asymmetric
    // memory region and MOT regions have special hash requirements and hence they do
    // not use the SLICE_HASH_MASK.
    //
    // Bits[19:6], RW, default = 0x0
    //
    UINTX slice_hash_mask : 14;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[30:20], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 11;
    //
    // Spare.  No identified usage yet
    //
    // Bits[31:31], RW, default = 0x0
    //
    UINTX spare : 1;
    //
    // Channel 1 in both slices are disabled no memory address mapped to ch 1. All requests
    // sent to channel 0.
    //
    // Bits[32:32], RW, default = 0x0
    //
    UINTX ch_1_disabled : 1;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[37:33], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_2 : 5;
    //
    // When both PMI channels in a slice are enabled this field specifies the Channel
    // Hash Mask to be applied on Addr[19:6] postremap DRAM address of the request to
    // compute which PMI channel a request must be routed to.  Relevant only when HVM
    // mode is disabled and only for requests that do not fall under the MOT region.
    //  Bunit will override the programmed value to include the Channel Selector bit
    // See SLICEHASH.INTERLEAVE_MODE field.  Note that HVM mode and MOT regions have
    // special hash requirements and hence they do not use the CH_HASH_MASK.
    //
    // Bits[51:38], RW, default = 0x0
    //
    UINTX ch_hash_mask : 14;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[62:52], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_3 : 11;
    //
    // Intended usage is for BIOS to set the LOCK when it updates the CR.  Aunit implements
    // only storage for this bit.  No hardware exists to implement hardware locking.
    //  NOTE:  Bunit copy of this bit is used by ucode to protect WRMSR to the Bunit's
    // CR.  Ucode has no access to the Aunit's copy of the CR
    //
    // Bits[63:63], RW, default = 0x0
    //
    UINTX lock : 1;
  } Bits;
  UINTX Data;
} A_CR_SLICE_CHANNEL_HASH_0_0_0_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC

#define A_CR_MIRROR_RANGE_0_0_0_MCHBAR_AUNIT_REG           0x000065C8
#ifndef ASM_INC
typedef union {
  struct {
    //
    // Mirror Base: specifies b38:b23 of HPA indicating the start of mirror packet buffer
    // region
    //
    // Bits[15:0], RW, default = 0x0
    //
    UINTX mirror_base : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[31:16], Unknown, default = Unknown
    //
    UINTX missing_from_register_description : 16;
    //
    // Mirror Limit: specifies b38:b23 of HPA indicating the end of mirror packet buffer
    // region
    //
    // Bits[47:32], RW, default = 0x0
    //
    UINTX mirror_limit : 16;
    //
    // Missing bits not found in register description spreadsheet.
    // Bits[63:48], Unknown, default = Unknown
    //
    UINTX missing_from_register_description_1 : 16;
  } Bits;
  UINTX Data;
} A_CR_MIRROR_RANGE_0_0_0_MCHBAR_AUNIT_STRUCT;
#endif // ASM_INC


#endif // _AUNIT_H_
